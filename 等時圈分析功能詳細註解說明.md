# 等時圈分析圖層 - 詳細程式註解說明

## 📋 概述

本文檔詳細說明了等時圈分析圖層的所有程式註解，幫助開發者理解系統架構、API 整合、演算法實現和功能流程。

## 🏗️ 系統架構

### 核心組件

- **OpenRouteService API 整合**: 調用真實交通網路數據
- **射線投射算法**: 判斷點是否在多邊形內
- **回退機制**: API 失敗時的圓圈分析
- **數據管理**: 統計、表格、視覺化數據處理

## 🔧 主要函數詳細說明

### 1. 🌐 API 整合函數

#### `fetchIsochroneData(lat, lng, travelTimeMinutes)`

```javascript
/**
 * 從 OpenRouteService API 獲取等時圈（Isochrone）數據
 *
 * @description 此函數向 ORS API 發送請求，獲取從指定起點在指定時間內可到達的所有區域
 * 等時圈是指從某一點出發，在相同時間內可以到達的所有地點連成的邊界線
 *
 * @param {number} lat - 起點緯度（WGS84 坐標系）
 * @param {number} lng - 起點經度（WGS84 坐標系）
 * @param {number} travelTimeMinutes - 旅行時間（分鐘），默認為 10 分鐘
 *
 * @returns {Promise<Object>} 返回 GeoJSON 格式的等時圈數據
 * @throws {Error} 當 API 調用失敗時拋出錯誤
 */
```

**功能特點:**

- 使用免費的 OpenRouteService API
- 支援多種交通模式（目前使用 driving-car）
- 每日 2000 次請求限制
- 返回 GeoJSON 格式的多邊形數據

### 2. 🎯 空間分析函數

#### `calculatePointsInIsochronePolygon(isochroneData, centerLat, centerLng)`

```javascript
/**
 * 計算等時圈多邊形範圍內的所有點物件（長照設施等）
 *
 * @description 此函數遍歷所有可見的點圖層，檢查每個點是否位於等時圈多邊形內部
 * 使用射線投射算法（Ray Casting Algorithm）判斷點是否在多邊形內
 */
```

**技術細節:**

- 使用射線投射算法進行點在多邊形內的判斷
- 支援 Polygon 和 MultiPolygon 類型
- 計算與中心點的直線距離
- 按距離排序結果

#### `isPointInPolygon(point, polygon)`

```javascript
/**
 * 使用射線投射算法（Ray Casting Algorithm）判斷點是否在多邊形內部
 *
 * @description 此算法的基本原理：
 * 1. 從測試點向任意方向（通常是水平向右）發射一條射線
 * 2. 計算射線與多邊形邊界的交點數量
 * 3. 如果交點數量為奇數，則點在多邊形內；偶數則在外
 */
```

**算法說明:**

- 經典的計算機圖形學算法
- 時間複雜度: O(n)，n 為多邊形頂點數
- 處理邊界情況和數值精度問題

### 3. 🚀 核心分析函數

#### `addIsochroneAnalysisPoint(lat, lng, travelTimeMinutes)`

```javascript
/**
 * 添加等時圈分析點 - 核心功能函數
 *
 * @description 這是等時圈分析功能的主要入口點。此函數會：
 * 1. 調用 OpenRouteService API 獲取真實的等時圈數據
 * 2. 計算等時圈範圍內的所有長照設施和相關區域
 * 3. 創建可視化的等時圈多邊形和分析點
 * 4. 生成統計數據和報告
 * 5. 在 API 失敗時提供回退方案
 */
```

**執行流程:**

1. **第一階段**: 調用 ORS API 獲取等時圈數據
2. **第二階段**: 基於等時圈多邊形計算範圍內的設施和區域
3. **第三階段**: 統計各圖層的設施數量
4. **第四階段**: 創建分析結果的顯示名稱
5. **第五階段**: 創建等時圈多邊形要素（用於地圖顯示）
6. **第六階段**: 將新創建的要素添加到圖層

### 4. 🔄 錯誤處理與回退機制

#### `addSimpleIsochroneAnalysisPoint(lat, lng, pointId)`

```javascript
/**
 * 簡單圓圈分析 - API 失敗時的回退方案
 *
 * @description 當 OpenRouteService API 調用失敗時（如網路錯誤、API 限制等），
 * 使用此函數提供基本的分析功能。以指定半徑的圓圈代替等時圈多邊形，
 * 雖然不如真實等時圈精確，但仍能提供基本的距離分析。
 */
```

**回退策略:**

- 使用 3 公里半徑作為預估等時圈範圍
- 保持與主要功能相同的數據結構
- 提供基本的距離分析功能
- 在 UI 中清楚標示為預估範圍

## 📊 數據管理與更新

### `updateIsochroneAnalysisLayerData(isochroneLayer)`

```javascript
/**
 * 更新等時圈分析圖層的統計數據和表格數據
 *
 * @description 此函數負責更新等時圈分析圖層的所有統計資訊，
 * 包括摘要數據（summaryData）和表格數據（tableData）。
 * 支援兩種類型的等時圈要素：真實的多邊形和回退的圓圈。
 */
```

**數據結構:**

- `summaryData`: 摘要統計（總數量、類型描述）
- `tableData`: 表格顯示數據（編號、名稱、類型、車程時間、統計數量）

## 🗑️ 管理功能

### 刪除功能

```javascript
/**
 * 刪除指定的等時圈分析點及其相關要素
 *
 * @description 此函數會移除指定編號的等時圈分析結果，包括：
 * 1. 等時圈多邊形或圓圈（分析範圍的視覺表示）
 * 2. 分析點標記（藍色加號圖標）
 * 3. 更新相關的統計數據和表格數據
 */
```

### 清除功能

```javascript
/**
 * 清除等時圈分析圖層的所有數據
 *
 * @description 此函數會移除等時圈分析圖層中的所有分析結果，
 * 包括等時圈多邊形、分析點標記和相關統計數據。
 * 通常在使用者需要重新開始分析或清空地圖時調用。
 */
```

## 🎨 圖層配置

### 等時圈分析圖層定義

```javascript
/**
 * 等時圈分析圖層配置
 *
 * @description 此圖層提供基於真實交通網路的等時圈分析功能，
 * 使用 OpenRouteService API 計算從指定起點在指定時間內可到達的所有區域，
 * 並分析範圍內的長照設施和相關統計數據。
 *
 * 功能特色：
 * - 🌐 調用 ORS API 獲取真實的等時圈多邊形
 * - 🎯 精確計算等時圈範圍內的設施數量
 * - 🔄 API 失敗時提供圓圈分析回退方案
 * - 📊 生成詳細的統計報告和表格數據
 * - 🎨 支援多邊形和圓圈兩種視覺表示方式
 */
```

## 🔍 要素類型說明

### 等時圈要素類型

1. **`isochrone-polygon-analysis`**: 來自 ORS API 的真實等時圈多邊形
2. **`isochrone-circle-analysis`**: 回退模式的圓圈分析
3. **`isochrone-point-analysis`**: 分析點標記（藍色加號）

### 數據流程

```
用戶點擊地圖 → 調用 ORS API → 獲取等時圈多邊形 → 計算範圍內設施 → 創建視覺要素 → 更新統計數據
       ↓ (API 失敗)
    回退到圓圈分析 → 使用 3km 半徑 → 計算範圍內設施 → 創建圓圈要素 → 更新統計數據
```

## 🛠️ 技術限制與注意事項

### API 限制

- OpenRouteService 免費版每日 2000 次請求
- 單次請求最多支援 5 個起點
- 最大等時圈時間為 60 分鐘

### 算法限制

- 點在多邊形內算法只處理外環，未考慮內環（洞）
- 多邊形重疊檢測使用簡化算法，可能遺漏邊緣相交情況
- 距離計算為直線距離，非實際行車距離

### 性能考量

- 大量點位時可能影響計算速度
- 複雜多邊形的相交計算較耗時
- 建議對可見圖層數量進行限制

## 📝 開發建議

### 未來改進方向

1. **增強算法**: 實現完整的多邊形相交算法
2. **緩存機制**: 對相同位置的等時圈結果進行緩存
3. **批量分析**: 支援同時分析多個起點
4. **更多交通模式**: 支援步行、自行車、公共交通等
5. **時間段分析**: 考慮不同時間段的交通狀況

### 維護要點

1. 定期檢查 API 金鑰有效性
2. 監控 API 使用量，避免超出限制
3. 測試回退機制的可靠性
4. 優化大數據集的處理效能

---

_此文檔記錄了等時圈分析圖層的完整技術實現，包含詳細的函數註解、算法說明和系統架構。開發者可以參考此文檔理解代碼邏輯並進行後續開發維護。_
